var fs = require('fs');
var path = require('path');

function bundleChanges(srcFolder, distFolder) {
    function readJSON(jsonPath, del) {
        return new Promise((resolve, reject) => {
            fs.readFile(jsonPath, 'utf8', function (err, data) {
                if (err) {
                    reject(err);
                }
                if (del) fs.unlinkSync(jsonPath);
                var parsed = JSON.parse(data);
                resolve(parsed);
            });
        });
    }

    function writeJSON(jsonPath, data) {
        return new Promise((resolve, reject) => {
            var dir = path.dirname(jsonPath);
            var pathsToCreate = [];
            while (!fs.existsSync(dir)) {
                pathsToCreate.push(dir);
                dir = path.dirname(dir);
            }
            pathsToCreate.reverse().forEach(function (dir) {
                fs.mkdirSync(dir);
            });
            data.sort(function (cA, cB) {
                return new Date(cA.creation || 0) - new Date(cB.creation || 0);
            });
            fs.writeFile(jsonPath, JSON.stringify(data), function (err, data) {
                if (err) {
                    reject(err);
                }
                resolve();
            });
        });
    }

    function listFilesInFolder(folderPath, doRecursive) {
        var files = [];
        var folderStat = fs.statSync(folderPath);
        if (!folderStat.isDirectory()) {
            return files;
        }
        var items = fs.readdirSync(folderPath);
        items.forEach(function(item) {
            var itemPath = path.resolve(folderPath, item);
            var stat = fs.statSync(itemPath);

            if (stat.isDirectory() && doRecursive) {
                files = files.concat(listFilesInFolder(itemPath, doRecursive));
            } else if (stat.isFile()) {
                files.push(itemPath);
            }
        });
        return files;
    }

    function filterForChangeFileType (sPath) {
        return sPath.endsWith(".change");
    }

    return new Promise((resolve, reject) => {
        if (!srcFolder || !distFolder) {
            resolve();
        }
        var changesSourceFolder = path.join(srcFolder, 'changes');
        var changesTargetFolder = path.join(distFolder, 'changes');

        if (fs.existsSync(changesSourceFolder)) {
            var changesBundle = path.join(changesTargetFolder, 'changes-bundle.json');
            var filePaths = [];
            try {
                filePaths = listFilesInFolder(changesSourceFolder, true);
            } catch (err) {
                reject(err);
            }

            filePaths = filePaths.filter(filterForChangeFileType);
            var actions = filePaths.map(item => {
                return readJSON(item, false);
            });
            return Promise.all(actions).then(results => {
                return writeJSON(changesBundle, results).then(() => {
                    resolve();
                });
            }).catch((err) => {
                grunt.log.warn("failed to read changes file");
                reject(err);
            });
        } else {
            resolve();
        }
    });
}

function cleanupChanges(srcFolder) {
    return new Promise((resolve, reject) => {
        if (!srcFolder) {
            resolve();
        }
        var changesTargetFolder = path.join(srcFolder, 'changes');
        if (fs.existsSync(changesTargetFolder)) {
            return fs.readdir(changesTargetFolder, function (err, items) {
                if (err) {
                    reject(err);
                }
                var deletedItemCount = 0;
                if (items) {
                    items.map(item => {
                        if (path.extname(item) == '.change') {
                            fs.unlinkSync(path.join(changesTargetFolder, item));
                            deletedItemCount++;
                        }
                    });
                }
                resolve();
            });
        } else {
            resolve();
        }
    });
}


function validateTaskOptions(grunt, task, taskOptions, withDest) {
    if (!taskOptions.src) {
        grunt.log.error(task.name + ' missing src configuration');
        return false;
    }
    if (withDest && !taskOptions.dest) {
        grunt.log.error(task.name + ' missing dest configuration');
        return false;
    }
    return true;
}

function getGruntConfiguredOptions(grunt) {
    return {
        src: grunt.config.get('dir.appFolder'),
        dest: grunt.config.get('dir.tmpDir')
    }
}

module.exports = function(grunt) {
    grunt.registerTask("bundleChanges", 'Task to bundle level-0-changes.', function () {
        var done = this.async();
        //get tasks configured options or set default if not exists
        var originOptions = this.options(getGruntConfiguredOptions(grunt));
        var _options = originOptions;

        if (validateTaskOptions(grunt, this, _options, true)) {
            bundleChanges(_options.src, _options.dest).then(() => {
                done();
            }).catch((err) => {
                grunt.log.warn("failed to bundle level-0-changes");
                done();
            });
        } else {
            done();
        }
    });

    grunt.registerTask("cleanupChanges", 'Task to delete level-0-changes in dist folder.', function () {
        var done = this.async();
        //get tasks configured options or set default if not exists
        var originOptions = this.options(getGruntConfiguredOptions(grunt));
        var _options = originOptions;

        if (validateTaskOptions(grunt, this, _options, false)) {
            cleanupChanges(_options.src).then(() => {
                done();
            }).catch((err) => {
                grunt.log.warn("failed to delete level-0-changes in dist folder");
                done();
            });
        } else {
            done();
        }
    });

}
